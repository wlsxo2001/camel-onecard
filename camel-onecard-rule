처음 시작시 각 플레이어당 5장씩 드로우

<승리 조건>
1. 본인 덱의 카드 수가 0장일때 승리
2. 본인을 제외하고 다 탈락했을 때 승리

<탈락 조건>
1. 카드 수가 10장 이상일 경우
2. 조커 2개를 전부 획득했을 경우

<게임 규칙>
1. "오픈카드 모양 == 내 카드 모양" 일 때 한 번 낼 수  있음
2. "오픈카드 숫자 == 내 카드 숫자" 일 때 연속해서 낼 수 있음

3. 공격 카드:공격 카드 2(2장 공격), ACE(3장 공격), Joker(4장 공격)이고 색깔 상관 x, 다음 턴의 상대방에게 공격
    3-1. 공격카드 2와 ACE는 3으로 방어 가능
    3-2. 조커는 방어 불가
4. 모양 전환 카드 7: 모양 바꾸고 다음 턴으로 넘김, 연속 내기 가능
5. Jack카드 : 다음 상대방이 아닌 다다음 상대방, 연속 내기 가능
6. Queen카드 : 차례가 역순으로 바뀜, 연속 내기 가능
7. King카드 : 자기 턴 한 번 더 생김, 연속 내기  가능


<코딩 규칙>
1. Game, Card, Deck, Player 클래스를 생성하고 그 안에서 원카드를 구현.
2. 위 클래스들을 부모 클래스로 하고 상속은 각자 알아서.
3. 다른 사람들이 플레이어 객체 내의 멤버 변수,메서드를 활용해서 플레이어 구현을 할 수 있도록 짜야함


<추가 및 수정 사안>
1. 인원 동적 할당 (2~6명 까지 가능하도록, 이름 입력하여 ',' 파싱으로 구분) (o)
2. player별 번호 지정이 필요할듯(nextplayer, play순서를 원활히 활용할 수 있도록, index번호로 활용) (o)
2. 공격카드 누적공격 가능하게. (o)
3. deck 소진 시 shuffle(사용 카드를 따로 모아놔야함.) (o)
4. J,Q,K 각 카드의 기능 구현
- Q(순서 반대로) : std::reverse(players.begin(), players.end()); 이용하면 순서 변경 가능 (o)
- J(한명 점프)   : currentPlayerIndex = (currentPlayerIndex + 2) % players.size(); 를 이용 (o)
- K(턴 한번더)   : 원래 하던 방식 (o)
5. 카드를 내기 전에 hand에서 최적의 패를 찾기(player 내의 어떠한 함수로 설정해서 인원들이 그 함수를 수정할 수 있도록)
6. 7번 카드 유지 시에는 턴 종료 아니고 더 낼 수도 있음. (o)
7. Game에서 최적의 카드 내는 알고리즘 Player로 빼야함.(o)
8. 승리자, 탈락자 저장 후 최종순위 출력. (o)
9. deck을 다 사용하고 다시 shuffle할 때 usedAttackCards를 초기화 해줘야함. (o)
10. 각자 Player의 optimalCard,counterCard 실행할 때마다 Game 클래스에서 canPlayCard와 canDefend 를 체크해줘야함.(편법 방지)

